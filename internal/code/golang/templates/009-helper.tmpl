
// RPC UTILITIES
// Helper utilities for dealing with RPC's adapters

type rpcMsg interface {
	Topic() string
	Data() []byte
	Reply(data []byte) error
}

type recvFunc func(msg rpcMsg)

type rpcAdaptor interface {
	Register(topic string, recv recvFunc) (drain func(), err error)
	Send(ctx context.Context, topic string, data []byte) ([]byte, error)
}

func rpcSend[T any](ctx context.Context, adaptor rpcAdaptor, topic string, in any, out *T) (*T, error) {
	data, err := json.Marshal(in)
	if err != nil {
		return nil, err
	}

	data, err = adaptor.Send(ctx, topic, data)
	if err != nil {
		return nil, err
	}

	if data[0] != '{' {
		err = errors.New(string(data))
		return nil, err
	}

	err = json.Unmarshal(data, out)
	if err != nil {
		return nil, err
	}

	return out, nil
}

// CONTEXT UTILITIES
// Injecting/extracting values from context usually used for http handlers

type ctxKey string

const (
	ctxKeyRequest  ctxKey = "http_request"
	ctxKeyResponse ctxKey = "http_response"
	ctxKeyClientMapper ctxKey = "ella_http_client_mapper"
)

type ctxClientMapper struct {
	HttpResponse *http.Response
}

// CreateCtxClientMapper inject a special object into the context which
// let's Ella's generated code to inject some values to the context
// Please refer to GetCtxClientMapper for accessing the values
// NOTE: use this function only in test functions, to get access to http.Response object
// of the http client to extract cookies, headers, etc.
func CreateCtxClientMapper(ctx context.Context) context.Context {
	return context.WithValue(ctx, ctxKeyClientMapper, &ctxClientMapper{})
}

func GetCtxClientMapper(ctx context.Context) (*ctxClientMapper, bool) {
	return getCtxValue[*ctxClientMapper](ctx, ctxKeyClientMapper)
}

func GetCtxHttpRequest(ctx context.Context) (result *http.Request, ok bool) {
	return getCtxValue[*http.Request](ctx, ctxKeyRequest)
}

func GetCtxHttpResponse(ctx context.Context) (result http.ResponseWriter, ok bool) {
	return getCtxValue[http.ResponseWriter](ctx, ctxKeyResponse)
}

func getCtxValue[T any](ctx context.Context, key ctxKey) (result T, ok bool) {
	value := ctx.Value(key)
	if value == nil {
		return result, false
	}
	result, ok = value.(T)
	return result, ok
}

func injectCommonVars(ctx context.Context, w http.ResponseWriter, r *http.Request) context.Context {
	ctx = context.WithValue(ctx, ctxKeyRequest, r)
	ctx = context.WithValue(ctx, ctxKeyResponse, w)
	return ctx
}

func injectHttpClientResponse(ctx context.Context, resp *http.Response) {
	clientMapper, ok := ctx.Value(ctxKeyClientMapper).(*ctxClientMapper)
	if !ok {
		return
	}

	clientMapper.HttpResponse = resp
}

// HTTP SERVER UTILITIES
// Helper utilities for creating http servers

type httpServiceMethodHandler func(context.Context, http.ResponseWriter, *http.Request)

func createServiceMethodHandler[ReqMsg, RespMsg any](method string, hasFields bool, fn func(ctx context.Context, req *ReqMsg) (*RespMsg, error)) httpServiceMethodHandler {
	return func(ctx context.Context, w http.ResponseWriter, r *http.Request) {
		if r.Method != method {
			httpResponseError(w, Errorf(http.StatusMethodNotAllowed, nil, "method %q not allowed", r.Method))
			return
		}

		defer func() {
			if err := recover(); err != nil {
				// In case of a panic, serve a 500 error and then panic.
				w.WriteHeader(http.StatusInternalServerError)
				panic(err)
			}
		}()

		var reqMsg ReqMsg

		if method == http.MethodGet {
			if err := valuesToStruct(r.URL.Query(), &reqMsg); err != nil {
				w.WriteHeader(http.StatusBadRequest)
				return
			}
		} else if hasFields {
			if err := checkContentType(r, "application/json"); err != nil {
				w.WriteHeader(http.StatusUnsupportedMediaType)
				return
			}

			if err := json.NewDecoder(r.Body).Decode(&reqMsg); err != nil {
				w.WriteHeader(http.StatusBadRequest)
				return
			}
		}

		respMsg, err := fn(ctx, &reqMsg)
		if err != nil {
			httpResponseError(w, err)
			return
		}

		w.WriteHeader(http.StatusOK)
		json.NewEncoder(w).Encode(respMsg)
	}
}

type streamEvent struct {
	id    int64
	event string
	data  string
}

func createStreamServiceMethod[ReqMsg any](method string, hasFields bool, fn func(ctx context.Context, req *ReqMsg) (<-chan *streamEvent, error)) httpServiceMethodHandler {
	return func(ctx context.Context, w http.ResponseWriter, r *http.Request) {
		if r.Method != method {
			httpResponseError(w, Errorf(http.StatusMethodNotAllowed, nil, "method %q not allowed", r.Method))
			return
		}

		fluser, ok := w.(http.Flusher)
		if !ok {
			httpResponseError(w, Errorf(http.StatusInternalServerError, nil, "response writer does not support flushing"))
			return
		}

		defer func() {
			if err := recover(); err != nil {
				// In case of a panic, serve a 500 error and then panic.
				w.WriteHeader(http.StatusInternalServerError)
				panic(err)
			}
		}()

		var reqMsg ReqMsg

		if method == http.MethodGet {
			if err := valuesToStruct(r.URL.Query(), &reqMsg); err != nil {
				w.WriteHeader(http.StatusBadRequest)
				return
			}
		} else if hasFields {
			if err := checkContentType(r, "application/json"); err != nil {
				w.WriteHeader(http.StatusUnsupportedMediaType)
				return
			}

			if err := json.NewDecoder(r.Body).Decode(&reqMsg); err != nil {
				w.WriteHeader(http.StatusBadRequest)
				return
			}
		}

		ctx, cancel := context.WithCancel(ctx)
		defer cancel()

		events, err := fn(ctx, &reqMsg)
		if err != nil {
			httpResponseError(w, err)
			return
		}

		w.Header().Set("Content-Type", "text/event-stream")
		w.Header().Set("Cache-Control", "no-cache")
		w.Header().Set("Connection", "keep-alive")
		fluser.Flush()

		var buffer bytes.Buffer

		var lastID int64
		for item := range events {
			buffer.Reset()

			buffer.WriteString("id: ")
			buffer.WriteString(strconv.FormatInt(item.id, 10))
			buffer.WriteString("\nevent: ")
			buffer.WriteString(item.event)
			buffer.WriteString("\ndata: ")
			buffer.WriteString(item.data)
			buffer.WriteString("\n\n")

			_, err := io.Copy(w, &buffer)
			if err != nil {
				return
			}
			fluser.Flush()
			lastID = item.id
		}

		lastID++
		fmt.Fprintf(w, "id: %d\nevent: done\ndata: {}\n\n", lastID)
	}
}

func createStreamBinaryServiceMethod[ReqMsg any](method string, contentType string, hasFields bool, fn func(ctx context.Context, req *ReqMsg) (io.Reader, error)) httpServiceMethodHandler {
	return func(ctx context.Context, w http.ResponseWriter, r *http.Request) {
		if r.Method != method {
			httpResponseError(w, Errorf(http.StatusMethodNotAllowed, nil, "method %q not allowed", r.Method))
			return
		}

		defer func() {
			if err := recover(); err != nil {
				// In case of a panic, serve a 500 error and then panic.
				w.WriteHeader(http.StatusInternalServerError)
				panic(err)
			}
		}()

		var reqMsg ReqMsg

		if method == http.MethodGet {
			if err := valuesToStruct(r.URL.Query(), &reqMsg); err != nil {
				w.WriteHeader(http.StatusBadRequest)
				return
			}
		} else if hasFields {
			if err := checkContentType(r, "application/json"); err != nil {
				w.WriteHeader(http.StatusUnsupportedMediaType)
				return
			}

			if err := json.NewDecoder(r.Body).Decode(&reqMsg); err != nil {
				w.WriteHeader(http.StatusBadRequest)
				return
			}
		}

		ctx, cancel := context.WithCancel(ctx)
		defer cancel()

		streamReader, err := fn(ctx, &reqMsg)
		if err != nil {
			httpResponseError(w, err)
			return
		}
		if closer, ok := streamReader.(io.Closer); ok {
			defer closer.Close()
		}

		if contentType == "" {
			contentType = "application/octet-stream"
		}

		w.Header().Set("Content-Type", contentType)

		io.Copy(w, streamReader)
	}
}

func createServiceMethodUploadHandler[ReqMsg, RespMsg any](
	totalMaxSize int64,
	fn func(ctx context.Context, nextFile func() (string, io.Reader, error), req *ReqMsg) (*RespMsg, error),
) httpServiceMethodHandler {
	return func(ctx context.Context, w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			httpResponseError(w, Errorf(http.StatusMethodNotAllowed, nil, "method %q not allowed", r.Method))
			return
		}

		r.Body = http.MaxBytesReader(w, r.Body, totalMaxSize)

		reader, err := r.MultipartReader()
		if err != nil {
			httpResponseError(w, err)
			return
		}

		part, err := reader.NextPart()
		if err != nil {
			httpResponseError(w, err)
			return
		}

		if part.FormName() != "payload" {
			part.Close()
			httpResponseError(w, Errorf(http.StatusBadRequest, nil, "missing payload name"))
			return
		}

		var req ReqMsg
		err = json.NewDecoder(part).Decode(&req)
		part.Close()
		if err != nil {
			httpResponseError(w, err)
			return
		}

		nextFile := func() (string, io.Reader, error) {
			part, err := reader.NextPart()
			if err != nil {
				return "", nil, err
			}

			if part.FormName() != "files" {
				return "", nil, Errorf(http.StatusBadRequest, nil, "missing files field")
			}

			return part.FileName(), part, nil
		}

		resp, err := fn(ctx, nextFile, &req)
		if err != nil {
			httpResponseError(w, err)
			return
		}

		w.WriteHeader(http.StatusOK)
		json.NewEncoder(w).Encode(resp)
	}
}

// HTTP CLIENT UTILITIES
// Helper utilities for creating http clients

func urlPathJoin(host string, paths ...string) (string, error) {
	u, err := url.Parse(host)
	if err != nil {
		return "", err
	}

	u.Path = path.Join(u.Path, path.Join(paths...))
	return u.String(), nil
}

func callHttpEndpoint(ctx context.Context, client *http.Client, url string, method string, in any) (r io.ReadCloser, err error) {
	if !isStructEmpty(in) {
		if method == http.MethodGet {
			url, err = structToURL(url, in)
			if err != nil {
				return nil, err
			}
		} else {
			r = jsonEncodeReader(in)
		}
	}

	req, err := http.NewRequestWithContext(ctx, method, url, r)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Content-Type", "application/json")

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}

	injectHttpClientResponse(ctx, resp)

	if resp.StatusCode >= 300 {
		defer resp.Body.Close()
		err := &Error{}
		if err := json.NewDecoder(resp.Body).Decode(err); err != nil {
			return nil, err
		}
		return nil, err
	}

	return resp.Body, nil
}

func callHttpServiceMethod(ctx context.Context, client *http.Client, url string, method string, in any, out any) (err error) {
	r, err := callHttpEndpoint(ctx, client, url, method, in)
	if err != nil {
		return err
	}
	defer r.Close()

	if isStructEmpty(out) {
		return nil
	}

	return json.NewDecoder(r).Decode(out)
}

func sendHttpFilesUpload(ctx context.Context, client *http.Client, url string, method string, payload any, files func() (string, io.Reader, error), respBody any) error {
	pr, pw := io.Pipe()

	boundary := getRandomBoundary()

	go func() {
		var err error
		var part io.Writer
		var filename string
		var content io.Reader

		mw := multipart.NewWriter(pw)

		defer func() {
			mw.Close()
			if err != nil {
				pw.CloseWithError(err)
			} else {
				pw.Close()
			}
		}()

		err = mw.SetBoundary(boundary)
		if err != nil {
			return
		}

		part, err = mw.CreateFormField("payload")
		if err != nil {
			return
		}

		_, err = io.Copy(part, jsonEncodeReader(payload))
		if err != nil {
			return
		}

		for {
			filename, content, err = files()
			if errors.Is(err, io.EOF) {
				err = nil
				return
			} else if err != nil {
				return
			}

			part, err = mw.CreateFormFile("files", filename)
			if err != nil {
				return
			}

			_, err = io.Copy(part, content)
			if err != nil {
				return
			}
		}
	}()

	req, err := http.NewRequestWithContext(ctx, method, url, pr)
	if err != nil {
		return err
	}

	req.Header.Set("Content-Type", "multipart/form-data; boundary="+boundary)

	resp, err := client.Do(req)
	if err != nil {
		return err
	}

	injectHttpClientResponse(ctx, resp)

	defer resp.Body.Close()

	if resp.StatusCode >= 300 {
		err := &Error{}
		if err := json.NewDecoder(resp.Body).Decode(err); err != nil {
			return err
		}
		return err
	}

	return json.NewDecoder(resp.Body).Decode(respBody)
}

func callHttpServiceStreamMethod[Resp any](ctx context.Context, client *http.Client, url string, method string, in any) (<-chan Resp, error) {
	r, err := callHttpEndpoint(ctx, client, url, method, in)
	if err != nil {
		return nil, err
	}

	return parseStreamEvents[Resp](ctx, r), nil
}

func parseStreamEvents[T any](ctx context.Context, r io.ReadCloser) <-chan T {
	out := make(chan T, 1)

	scanner := bufio.NewScanner(r)

	// Set the scanner's split function to split on "\n\n"
	scanner.Split(func(data []byte, atEOF bool) (advance int, token []byte, err error) {
		// Return nothing if at end of file and no data passed
		if atEOF && len(data) == 0 {
			return 0, nil, nil
		}

		idx := bytes.Index(data, []byte("\n\n"))
		if idx >= 0 {
			return idx + 2, data[:idx], nil
		}

		if atEOF {
			return len(data), data, nil
		}

		// We need more data
		return 0, nil, nil
	})

	secondPart := func(prefix, value string) (string, bool) {
		if !strings.HasPrefix(value, prefix) {
			return "", false
		}
		return strings.TrimSpace(value[len(prefix):]), true
	}

	// Close the reader when the context is cancelled
	// this is make sure the scanner.Scan() will return false 
	// and the goroutine will exit
	go func () {
		<-ctx.Done()
		r.Close()
	}()

	go func() {
		defer close(out)
		for scanner.Scan() {
			item := scanner.Text()
			lines := strings.Split(item, "\n")

			if len(lines) != 3 {
				continue
			}

			identifier, ok := secondPart("id:", lines[0])
			if !ok {
				continue
			}

			// ignore id for now
			_, err := strconv.ParseInt(identifier, 10, 64)
			if err != nil {
				continue
			}

			// ignore event for now
			_, ok = secondPart("event:", lines[1])
			if !ok {
				continue
			}

			data, ok := secondPart("data:", lines[2])
			if !ok {
				continue
			}

			msg, ok := initalizePointer[T]()

			if ok {
				err = json.Unmarshal([]byte(data), msg)
			} else {
				err = json.Unmarshal([]byte(data), &msg)
			}
			if err != nil {
				continue
			}

			out <- msg
		}
	}()

	return out
}

func initalizePointer[T any]() (result T, ok bool) {
	if reflect.ValueOf(result).Kind() != reflect.Ptr {
		return
	}

	ok = true
	va := reflect.ValueOf(&result).Elem()
	v := reflect.New(va.Type().Elem())
	va.Set(v)

	return
}

func getRandomBoundary() string {
	var buf [30]byte
	_, err := io.ReadFull(rand.Reader, buf[:])
	if err != nil {
		panic(err)
	}
	return fmt.Sprintf("%x", buf[:])
}

// HTTP UTILITIES
// Helper utilities for dealing with http response and request

type emptyStruct struct{}

func isStructEmpty(value any) bool {
	_, ok := value.(*emptyStruct)
	return ok
}

func jsonEncodeReader(value any) io.ReadCloser {
	r, w := io.Pipe()
	go func() {
		err := json.NewEncoder(w).Encode(value)
		if err != nil {
			w.CloseWithError(err)
			return
		}
		w.Close()
	}()
	return r
}

func httpResponse(w http.ResponseWriter, code int, body any) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)

	switch body := body.(type) {
	case nil:
		return
	case io.Reader:
		io.Copy(w, body)
	default:
		json.NewEncoder(w).Encode(body)
	}
}

func isContentType(r *http.Request, contentType string) bool {
	header := r.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}

	return strings.TrimSpace(header[:i]) == contentType
}

func checkContentType(r *http.Request, contentType string) error {
	if !isContentType(r, contentType) {
		return Errorf(http.StatusUnsupportedMediaType, nil, "content type %q not supported", r.Header.Get("Content-Type"))
	}
	return nil
}

// QUERY URL UTILITIES
// Helper utilities for dealing with query url

func structToURL(host string, ptr any) (string, error) {
	u, err := url.Parse(host)
	if err != nil {
		return "", err
	}

	u.RawQuery = structToValues(ptr).Encode()

	return u.String(), nil
}

// structToValues converts a struct to url.Values
// supports only basic types, string, int, float, bool
// and ignores other complex types
func structToValues(ptr any) url.Values {
	values := url.Values{}
	v := reflect.Indirect(reflect.ValueOf(ptr))

	t := v.Type()
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		value := v.Field(i)

		// Convert the field value to a string
		var strValue string
		switch value.Kind() {
		case reflect.String:
			strValue = url.QueryEscape(value.String())
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
			strValue = strconv.FormatInt(value.Int(), 10)
		case reflect.Float32, reflect.Float64:
			strValue = strconv.FormatFloat(value.Float(), 'f', -1, 64)
		case reflect.Bool:
			strValue = strconv.FormatBool(value.Bool())
		default:
			continue
		}

		// Add the key-value pair to the values
		if strValue != "" {
			key := field.Tag.Get("json")
			if key == "" {
				key = field.Name
			}
			values.Add(key, strValue)
		}
	}
	return values
}

// valuesToStruct converts url.Values to a struct
// supports only basic types, string, int, float, bool
// returns an error if the struct contains unsupported types
func valuesToStruct(values url.Values, ptr any) error {
	dType := reflect.TypeOf(ptr)
	dhVal := reflect.ValueOf(ptr)

	for i := 0; i < dType.Elem().NumField(); i++ {
		field := dType.Elem().Field(i)
		key := field.Tag.Get("json")
		kind := field.Type.Kind()

		val := values.Get(key)

		result := dhVal.Elem().Field(i)

		switch kind {
		case reflect.String:
			val, err := url.QueryUnescape(val)
			if err != nil {
				return err
			}
			result.SetString(val)
		case reflect.Int:
			v, err := strconv.ParseInt(val, 10, 64)
			if err != nil {
				return err
			}
			result.SetInt(v)
		case reflect.Float64:
			v, err := strconv.ParseFloat(val, 64)
			if err != nil {
				return err
			}
			result.SetFloat(v)
		case reflect.Bool:
			v, err := strconv.ParseBool(val)
			if err != nil {
				return err
			}
			result.SetBool(v)
		default:
			return fmt.Errorf("unsupported type %s", kind)
		}
	}
	return nil
}

// ERROR UTILITIES
// Helper utilities for creating uniform error responses

type Error struct {
	code  int
	cause error
	msg   string
}

func (e *Error) UnmarshalText(text []byte) error {
	temp := struct {
		Code  int    `json:"code"`
		Casue string `json:"cause,omitempty"`
		Error string `json:"error"`
	}{}

	if err := json.Unmarshal(text, &temp); err != nil {
		return err
	}

	e.code = temp.Code
	e.msg = temp.Error
	e.cause = errors.New(temp.Casue)

	return nil
}

func (e Error) MarshalText() ([]byte, error) {
	temp := struct {
		Code  int    `json:"code"`
		Casue string `json:"cause,omitempty"`
		Error string `json:"error"`
	}{
		Code:  e.code,
		Error: e.Error(),
	}

	if e.cause != nil {
		temp.Casue = e.cause.Error()
	}

	return json.Marshal(temp)
}

func (e *Error) Error() string {
	var sb strings.Builder

	if e.msg != "" {
		sb.WriteString(e.msg)
	}

	if e.cause != nil {
		if sb.Len() > 0 {
			sb.WriteString(": ")
		}

		sb.WriteString(e.cause.Error())
	}

	return sb.String()
}

func (e *Error) Cause() error {
	return e.cause
}

func (e *Error) Unwrap() error {
	return e.cause
}

// Errorf is a way to create an error with a message and a cause
// cause can be nil if there is no cause, code can be any int, if it is
// a valid http status code, it will be used as http status code
func Errorf(code int, cause error, format string, args ...interface{}) error {
	return &Error{code: code, cause: cause, msg: fmt.Sprintf(format, args...)}
}

// IsError is an extension of errors.Is that also checks the error message
// in string format. This enables us to check errors during serlization/deserilization
// process
func IsError(err, target error) bool {
	if err == nil {
		return false
	}

	if err == target {
		return true
	}

	if err.Error() == target.Error() {
		return true
	}

	if err, ok := err.(*Error); ok {
		return IsError(err.cause, target)
	}

	return errors.Is(err, target)
}

// httpResponseError is a helper function that writes an error to the http response
// if the error is of type *Error, it will write the error code and message
// and if code is valid http status code, it will write the http status code
// otherwise it will write 500
func httpResponseError(w http.ResponseWriter, err error) {
	switch err := err.(type) {
	case *Error:
		if err.code < 100 || err.code > 599 {
			httpResponse(w, http.StatusInternalServerError, err)
			return
		}
		httpResponse(w, err.code, err)
	default:
		httpResponse(w, http.StatusInternalServerError, Errorf(http.StatusInternalServerError, err, ""))
	}
}
