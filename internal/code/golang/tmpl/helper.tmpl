
//
// Helper functions
//

// RPC

type rpcMsg interface {
    Topic() string
    Data() []byte
    Reply(reply []byte) error
}

type rpcAdaptor interface {
    Register(topic string, recv func(msg rpcMsg)) (drain func(), err error)
    Send(ctx context.Context, topic string, data []byte) ([]byte, error)
}

// Context

type CtxKey string

const (
	CtxKeyRequest CtxKey = "http_request"
	CtxKeyResponse CtxKey = "http_response"
)

func GetCtxValue[T any](ctx context.Context, key CtxKey) (result T, ok bool) {
	value := ctx.Value(key)
	if value == nil {
		return result, false
	}
	result, ok = value.(T)
	return result, ok
}

func GetCtxHttpRequest(ctx context.Context) (result *http.Request, ok bool) {
	return GetCtxValue[*http.Request](ctx, CtxKeyRequest)
}

func GetCtxHttpResponse(ctx context.Context) (result http.ResponseWriter, ok bool) {
	return GetCtxValue[http.ResponseWriter](ctx, CtxKeyResponse)
}

func injectCommonVars(ctx context.Context, w http.ResponseWriter, r *http.Request) context.Context {
	ctx = context.WithValue(ctx, CtxKeyRequest, r)
	ctx = context.WithValue(ctx, CtxKeyResponse, w)
	return ctx
}

func callServiceMethod[ReqMsg, RespMsg any](ctx context.Context, method string, client *http.Client, url string, in *ReqMsg, out *RespMsg) (err error) {
	var reqBody io.Reader

	if !isStructEmpty(in) {
		if method == http.MethodGet {
			url, err = structToURL(url, in)
			if err != nil {
				return err
			}
		} else {
			reqBody, err = jsonEncoder(in)
			if err != nil {
				return err
			}
		}
	}

	req, err := http.NewRequestWithContext(ctx, method, url, reqBody)
	if err != nil {
		return err
	}

	req.Header.Set("Content-Type", "application/json")

	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 300 {
		return parseError(resp.Body)
	}

	if isStructEmpty(out) {
		return nil
	}

	return json.NewDecoder(resp.Body).Decode(out)
}

type httpServiceMethodHandler func(context.Context, http.ResponseWriter, *http.Request)

func createServiceMethodHandler[ReqMsg, RespMsg any](method string, hasFields bool, fn func(ctx context.Context, req *ReqMsg) (*RespMsg, error)) httpServiceMethodHandler {
	return func(ctx context.Context, w http.ResponseWriter, r *http.Request) {
		if r.Method != method {
			ResponseError(w, Errorf(http.StatusMethodNotAllowed, "method %q not allowed", r.Method))
			return
		}

		defer func() {
			if err := recover(); err != nil {
				// In case of a panic, serve a 500 error and then panic.
				w.WriteHeader(http.StatusInternalServerError)
				panic(err)
			}
		}()

		if method != http.MethodGet {
			if err := checkContentType(r, "application/json"); err != nil {
				w.WriteHeader(http.StatusUnsupportedMediaType)
				return
			}
		}

		var reqMsg ReqMsg

		if hasFields && method == http.MethodPost {
			if err := json.NewDecoder(r.Body).Decode(&reqMsg); err != nil {
				w.WriteHeader(http.StatusBadRequest)
				return
			}
		} else if method == http.MethodGet {
			if err := valuesToStruct(r.URL.Query(), &reqMsg); err != nil {
				w.WriteHeader(http.StatusBadRequest)
				return
			}
		}

		respMsg, err := fn(ctx, &reqMsg)
		if err != nil {
			ResponseError(w, err)
			return
		}

		var buffer bytes.Buffer

		if err := json.NewEncoder(&buffer).Encode(respMsg); err != nil {
			ResponseError(w, err)
			return
		}

		io.Copy(w, &buffer)
		w.WriteHeader(http.StatusOK)
	}
}

// Utility functions

func structToValues(ptr any) url.Values {
	values := url.Values{}
	v := reflect.Indirect(reflect.ValueOf(ptr))

	t := v.Type()
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		value := v.Field(i)

		// Convert the field value to a string
		var strValue string
		switch value.Kind() {
		case reflect.String:
			strValue = url.QueryEscape(value.String())
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
			strValue = strconv.FormatInt(value.Int(), 10)
		case reflect.Float32, reflect.Float64:
			strValue = strconv.FormatFloat(value.Float(), 'f', -1, 64)
		case reflect.Bool:
			strValue = strconv.FormatBool(value.Bool())
		default:
			continue
		}

		// Add the key-value pair to the values
		if strValue != "" {
			key := field.Tag.Get("json")
			if key == "" {
				key = field.Name
			}
			values.Add(key, strValue)
		}
	}
	return values
}

func valuesToStruct(values url.Values, ptr any) error {
	dType := reflect.TypeOf(ptr)
	dhVal := reflect.ValueOf(ptr)

	for i := 0; i < dType.Elem().NumField(); i++ {
		field := dType.Elem().Field(i)
		key := field.Tag.Get("json")
		kind := field.Type.Kind()

		val := values.Get(key)

		result := dhVal.Elem().Field(i)

		switch kind {
		case reflect.String:
			val, err := url.QueryUnescape(val)
			if err != nil {
				return err
			}
			result.SetString(val)
		case reflect.Int:
			v, err := strconv.ParseInt(val, 10, 64)
			if err != nil {
				return err
			}
			result.SetInt(v)
		case reflect.Float64:
			v, err := strconv.ParseFloat(val, 64)
			if err != nil {
				return err
			}
			result.SetFloat(v)
		case reflect.Bool:
			v, err := strconv.ParseBool(val)
			if err != nil {
				return err
			}
			result.SetBool(v)
		default:
			return fmt.Errorf("unsupported type %s", kind)
		}
	}
	return nil
}

func structToURL(host string, ptr any) (string, error) {
	u, err := url.Parse(host)
	if err != nil {
		return "", err
	}

	u.RawQuery = structToValues(ptr).Encode()

	return u.String(), nil
}

func mergeChannels[Resp any](ctx context.Context, chans ...<-chan Resp) <-chan Resp {
	out := make(chan Resp)
	done := make(chan struct{})
	wait := make(chan struct{}, len(chans))

	output := func(c <-chan Resp) {
		defer func() {
			wait <- struct{}{}
		}()

		for n := range c {
			select {
			case <-done:
				return
			case out <- n:
			case <-ctx.Done():
				return
			}
		}
	}

	for _, c := range chans {
		go output(c)
	}

	go func() {
		defer close(done)
		defer close(out)

		for i := 0; i < len(chans); i++ {
			select {
			case <-wait:
			case <-ctx.Done():
				return
			}
		}
	}()

	return out
}

func checkContentType(r *http.Request, value string) error {
	header := r.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}

	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case value:
		return nil
	default:
		return Errorf(http.StatusBadRequest, "unexpected Content-Type: %q", r.Header.Get("Content-Type"))
	}
}

func urlPathJoin(host string, paths ...string) (string, error) {
	u, err := url.Parse(host)
	if err != nil {
		return "", err
	}

	u.Path = path.Join(u.Path, path.Join(paths...))
	return u.String(), nil
}

type emptyStruct struct{}

func isStructEmpty(value any) bool {
	_, ok := value.(*emptyStruct)
	return ok
}

func jsonEncoder(value any) (io.Reader, error) {
	r, w := io.Pipe()
	go func() {
		err := json.NewEncoder(w).Encode(value)
		if err != nil {
			w.CloseWithError(err)
			return
		}
		w.Close()
	}()
	return r, nil
}

// Error

func writeResponse(w http.ResponseWriter, code int, body any) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)

	switch body := body.(type) {
	case nil:
		return
	case io.Reader:
		io.Copy(w, body)
	default:
		json.NewEncoder(w).Encode(body)
	}
}

type Error struct {
	code  int
	cause error
	msg   string
}

func parseError(r io.Reader) *Error {
	msg := struct {
		Code  int    `json:"code"`
		Error string `json:"error"`
	}{}

	json.NewDecoder(r).Decode(&msg)

	return &Error{
		code: msg.Code,
		msg:  msg.Error,
	}
}

func (e Error) MarshalJSON() ([]byte, error) {
	return json.Marshal(struct {
		Code  int    `json:"code"`
		Error string `json:"error"`
	}{
		Code:  e.code,
		Error: e.Error(),
	})
}

func (e *Error) Error() string {
	var sb strings.Builder

	sb.WriteString(e.msg)
	if e.msg != "" && e.cause != nil {
		sb.WriteString(": ")
		sb.WriteString(e.cause.Error())
	} else if e.cause != nil {
		sb.WriteString(e.cause.Error())
	}

	return sb.String()
}

func (e *Error) Cause() error {
	return e.cause
}

func (e *Error) Unwrap() error {
	return e.cause
}

func Errorf(code int, format string, args ...interface{}) error {
	return &Error{code: code, msg: fmt.Sprintf(format, args...)}
}

func WrapErr(code int, cause error, msg string) error {
	return &Error{code: code, cause: cause, msg: msg}
}

func ResponseError(w http.ResponseWriter, err error) {
	switch err := err.(type) {
	case *Error:
		writeResponse(w, err.code, err)
	default:
		writeResponse(w, http.StatusInternalServerError, WrapErr(http.StatusInternalServerError, err, ""))
	}
}

func rpcSend[T any](ctx context.Context, adaptor rpcAdaptor, topic string, in any, out *T) (*T, error) {
	data, err := json.Marshal(in)
	if err != nil {
		return nil, err
	}

	data, err = adaptor.Send(ctx, RpcHrGetTopic, data)
	if err != nil {
		return nil, err
	}

	if data[0] != '{' {
		err = errors.New(string(data))
		return nil, err
	}

	err = json.Unmarshal(data, out)
	if err != nil {
		return nil, err
	}

	return out, nil
}